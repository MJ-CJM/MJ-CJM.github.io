<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>client-go</title>
      <link href="client-go/"/>
      <url>client-go/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 系统使用 client-go 作为 Go 语言的官方编程式交互客户端库，提供对 Kubernetes API Server 服务的交互访问。client-go 的源码路径为 vendor/k8s.io/client-go。</p><h2 id="client-go-源码结构"><a href="#client-go-源码结构" class="headerlink" title="client-go 源码结构"></a>client-go 源码结构</h2><table><thead><tr><th>源码目录</th><th>说明</th></tr></thead><tbody><tr><td>discovery</td><td>提供 DiscoveryClient 发现客户端</td></tr><tr><td>dynamic</td><td>提供 DynamicClient 动态客户端</td></tr><tr><td>informers</td><td>每种 Kubernetes 资源的 Informer 实现</td></tr><tr><td>kubernetes</td><td>提供 ClientSet 客户端</td></tr><tr><td>listers</td><td>为每一个 Kubernetes 资源提供 Lister 功能，该功能对 Get 和 List 请求提供只读的缓存数据</td></tr><tr><td>plugin</td><td>提供 OpenStack 、GCP 和 Azure 等云服务商授权插件</td></tr><tr><td>rest</td><td>提供 RESTClient 客户端，对 Kubernetes API Server 执行 RESTful 操作</td></tr><tr><td>scale</td><td>提供 ScaleClient 客户端，用于扩容或缩容 Deployment,ReplicaSet,Replication Controller 等资源对象</td></tr><tr><td>tools</td><td>提供常用工具，例如 SharedInformer,Reflector,DealtFIFO 及 Indexers。提供 Client 查询和缓存机制，以减少向 kube-apiserver 发起的请求数等</td></tr><tr><td>transport</td><td>提供安全的 TCP 连接，支持 Http Stream,某些操作需要在客户端和容器之间传输二进制流，例如 exec,attach 等操作，该功能由内部的 spdy 包提供支持</td></tr><tr><td>util</td><td>提供常用方法，例如 WorkQueue 工作队列，Certificate 证书管理等</td></tr></tbody></table><h2 id="Client-客户端对象"><a href="#Client-客户端对象" class="headerlink" title="Client 客户端对象"></a>Client 客户端对象</h2><ul><li><p>RESTClient 是最基础的客户端，RESTClient 对 HTTP Request 进行了封装，实现了 RESTful 风格的 API。ClientSet,DynamicClient 及 DiscoveryClient 客户端都是基于 RESTClient 实现的。</p></li><li><p>ClientSet 在 RESTClient 的基础上封装了对 Resource 和 Version 的管理方法，每一个 Resource 可以理解为一个客户端，而 ClientSet 则是多个客户端的集合，每一个 Resource 和 Version 都以函数的方式暴露给开发者。ClientSet 只能够处理 Kubernetes 内置资源，它是通过 client-gen 代码生成器自动生成的。</p></li><li><p>DynamicClient 与 ClientSet 最大的不同之处是，ClientSet 仅能访问 Kubernetes 自带的资源，不能直接访问 CRD 自定义资源，DynamicClient 能够处理 Kubernetes 中的所有资源对象，包括 Kubernetes 内置资源与 CRD 自定义资源。</p></li><li><p>DiscoveryClient 发现客户端，用于发现 kube-apiserver 所支持的资源组、资源版本、资源信息。</p></li></ul><p>以上 4 中客户端都可以通过 kubeconfig 配置信息连接到指定的 Kubernetes API Server。</p><h3 id="kubeconfig-配置管理"><a href="#kubeconfig-配置管理" class="headerlink" title="kubeconfig 配置管理"></a>kubeconfig 配置管理</h3><p>kubeconfig 用于管理访问 kube-apiserver 的配置信息，同时也支持访问多 kube-apiserver 的配置管理，可以再不同的环境下管理不同的 kube-apiserver 集群配置，不同业务线也可以拥有不同的集群，kubernetes 的其他组件都使用 kubeconfig 配置信息来连接 kube-apiserver 组件的。</p><p>Kubeconfig 配置信息如下：</p><pre><code>$ cat ~/.kube/configapiVersion: v1kind: Configpreferences: {}clusters:- cluster:    name: dev-clusterusers: - name: dev-usercontexts:- context  name: dev-context</code></pre><ul><li>clusters: 定义 Kubernetes 集群信息，例如 kube-apiserver 的服务地址及集群的证书信息等。</li><li>users: 定义 Kubernetes 集群用户身份验证的客户端凭据，例如 client-certificate、client-key、token及username/password 等。</li><li>contests: 定义 Kubernetes 集群用户信息和命名空间等，用于将请求发送到指定的集群。</li></ul><p>client-go 会读取 kubeconfig 配置信息并生成 config 对象，用于与 kube-apiserver 通信，代码示例如下： </p><pre><code>func main() {    config, err := clientcmd.BuildConfigFromFlags("", "~/.kube/config")    if err != nil {        panic(err)    }    ...}</code></pre><p>上述代码中，clientcmd.BuildConfigFromFlags 函数会读取 kubeconfig 配置信息并实例化 rest.Config 对象，其中 kubeconfig 最核心的功能是管理多个访问 kube-apiserver 集群的配置信息，将多个配置信息合并成一份，在合并过程中会解决多个配置文件字段冲突的问题，该过程由 Load 函数完成，可以分为两步：第一步，加载 kubeconfig 配置信息；第二步，合并多个 kubeconfig 配置信息。代码示例如下：</p><ol><li>加载 kubeconfig 配置信息</li></ol><pre><code>func (rules *ClientConfigLoadingRules) Load() (*clientcmdapi.Config, error) {    ...    kubeConfigFiles := []string{}    ...    if len(rules.ExplicitPath) &gt; 0 {        ...        kubeConfigFiles = append(kubeConfigFiles, rules.ExplicitPath)    } else {        kubeConfigFiles = append(kubeConfigFiles, rules.Precedence...)    }    for _, filename := range kubeConfigFiles {        ...        config, err := LoadFromFile(filename)        ...        kubeconfigs = append(kubeconfigs, config)    }    ...}</code></pre><p>从上可知，有以上两种方式可以获取 kubeconfig 配置信息路径：第一种，文件路径（即 rules.ExplicitPath）；第二种，环境变量（通过 KUBECONFIG 变量，即 rules.Precedence,可指定多个路径）。最后将配置信息汇总到 kubeConfigFiles 中，这两种方式都通过 LoadFromFile 函数读取数据并把读取到的数据反序列化到 Config 对象中。代码示例如下：</p><pre><code>func Load(data []byte) (*clientcmdapi.Config, error) {    config := clientcmdapi.NewConfig()    ...    decoded, _, err := clientcmdlatest.Codec.Decode(data, &amp;schema.GroupVersionKind{Version: clientcmdlatest.Version, Kind: "Config"}, config)    ...    return decoded.(*clientcmdapi.Config), nil}</code></pre><ol start="2"><li>合并多个 kubeconfig 配置信息</li></ol><p>代码示例如下：</p><pre><code>config := clientcmdapi.NewConfig()mergo.MergeWithOverwrite(config, mapConfig)mergo.MergeWithOverwrite(config, nonMapConfig)</code></pre><p>mergo.MergeWithOverwrite 函数将 src 字段填充到 dst 结构中，私有字段除外，非空的 dst 字段将被覆盖，另外 dst 和 src 必须拥有有效的相同类型结构。</p><h3 id="RESTClient-客户端"><a href="#RESTClient-客户端" class="headerlink" title="RESTClient 客户端"></a>RESTClient 客户端</h3><p>它具有很高的灵活性，数据不依赖于方法和资源，因此 RESTClient 能够处理多种类型的调用，返回不同的数据格式。</p><p>RESTClient Example 代码示例如下：</p><pre><code>func main() {    config, err := clientcmd.BuildConfigFromFlags("", "/root/.kube/config")    if err != nil {        panic(err)    }    config.APIPath = "api"    config.GroupVersion = &amp;corev1.SchemeGroupVersion    config.NegotiatedSerializer = scheme.Codecs    restClient, err := rest.RESTClientFor(config)    // 通过 kubeconfig 配置信息实例化 RESTClient 对象。    if err != nil {        panic(err)    }    result := &amp;corev1.PodList{}    err = restClient.Get().Namespace("default").Resource("pods").VersionedParams(&amp;metav1.ListOptions{Limit:500}, scheme.ParameterCodec).Do().Into(result)    // RESTClient 对象构建 HTTP 请求参数。例如 GET, POST, PUT, DELETE, PATCH 等    // VersionedParams 函数将一些查询选项添加到请求参数中    if err != nil {        panic(err)    }    for _, d := range result.Items {        fmt.Printf("NAMESPACE:%v \t NAME: %v \t STATU: %+v \n", d.Namespace, d.Name, d.Status.Phase)    }}</code></pre><p>以上代码列出 defult 命名空间下的所有 Pod 资源对象的相关信息。首先加载 kubeconfig 配置信息，并设置 config.APIPath 请求的 HTTP 路径，然后设置 config.GroupVersion 请求的资源组/资源版本。最后设置 config.NegotiatedSerializer 数据的编码器。</p><p>RESTClient 发送请求的过程对 Go 语言标准库 net/http 进行了封装，由 Do -&gt; request 函数实现，代码示例如下：</p><pre><code>func (r *Request) Do() Result {    ...    var result Result    err := r.request(func(req *http.Request, resp *http.Response) {        result = r.transformResponse(resp, req)    })}func (r *Request) request(fn func(*http.Request, *http.Response)) error {    ...    for {        url := r.URL().String()        // 生成请求的 RESTful URL        req, err := http.NewRequest(r.verb, url, r.body)        // 通过 Go 语言标准库 net/http 向 RESTful URL(即 kube-apiserver)发送请求。        if err != nil {            return err        }        ...        req.Header = r.headers        ...        resp, err := client.Do(req)        ...        if err != nil {            if !net.IsConnectionReset(err) || r.verb != "GET" {                return err            }            resp = &amp;http.Response{                StatusCode: http.StatusInternalServerError,                Header: http.Header{"Retry-After": []string{"1"}},                Body:   iotil.NopCloser(bytes.NewReader([]byte{})),                // 请求得到的结果存放在 http.Respose 的 Body 中            }        }        ...        resp.Body.Close()        // 函数退出时，会通过此命令进行关闭，防止内存溢出        ...        fn(req, resp)        // 将结果转换为资源对象        ...    }}</code></pre><h3 id="ClientSet-客户端"><a href="#ClientSet-客户端" class="headerlink" title="ClientSet 客户端"></a>ClientSet 客户端</h3>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> client-go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubectl 命令行交互</title>
      <link href="kubectl-commands/"/>
      <url>kubectl-commands/</url>
      
        <content type="html"><![CDATA[<p>从 Kubernetes 架构设计的角度来看，kubectl 工具是 Kubernetes API Server 的客户端。一些命令可以自行查阅。</p><h2 id="Cobra-命令行参数解析"><a href="#Cobra-命令行参数解析" class="headerlink" title="Cobra 命令行参数解析"></a>Cobra 命令行参数解析</h2><p>Cobra 是一个创建强大的现代化 CLI 命令行应用程序的 Go 语言库，可以用来生成应用程序的文件。</p><p>Cobra Example:</p><pre><code>func main() {    var Version bool    var rootCmd = &amp;cobra.Command{        Use: "root[sub]",        Short: "root command",        Run: func(cmd *cobra.Command, args []string) {            fmt.Printf("Inside rootCmd Run with args: %v\n", args)            if Version {                fmt.Printf("Version: 1.0\n")            }        },    }    flags := rootCmd.Flags()    flags.BoolVarP(&amp;Version, "version", "v", false, "Print version information and quit")    _ = rootCmd.Execute()}</code></pre><p>由此可知 Cobra 基本应用步骤分为如下 3 步：</p><ol><li>创建 rootCmd 主命令，并定义 Run 执行函数，也可以通过 rootCmd.AddCommand 方法添加子命令。</li><li>为命令添加命令行参数。</li><li>执行 rootCmd 命令调用的函数，rootCmd.Execute 会在内部回调 Run 执行函数。</li></ol><p>Kubernetes 核心组件都通过 Cobra 来管理 CLI 交互方式，<br>下面以 kubectl 为例：</p><pre><code>kubectl    get   pod  pod_name  -n kube-systemApp Name/Command/Type/  Name  / Flag</code></pre><ul><li>Command: 指定命令操作，命令后可以加子命令。</li><li>TYPE: 指定资源类型，资源类型不区分大小写。</li><li>NAME: 指定资源名称，可以指定多个，资源名称需要区分大小写。</li><li>Flag: 指定可选命令行参数</li></ul><p>同样是三步骤 1：创建 Command, 2: 为 get 命令添加命令行参数 3：执行命令</p><h3 id="创建-Command"><a href="#创建-Command" class="headerlink" title="创建 Command"></a>创建 Command</h3><p>实例化 cobra.Command 对象，并通过 cmds.AddCommand 方法添加命令或子命令，每个 cobra.Command 对象都可设置 Run 执行函数，<br>代码示例如下：</p><pre><code>func NewKubectlCommand(in io.Reader, out, err io.Writer)  *cobra.Command {    ...    groups := templates.CommandGroups{        ...        {            Message: "Basic Commands (Intermediate):",            Commands: []*cobra.Command{                explain.NewCmdExplain("kubectl", f, ioStreams),                get.NewCmdGet("kubectl", f, isStreams),                edit.NewCmdEdit(f, ioStreams),                delete.NewCmdDelete(f, ioStreams),            },        },        ...    }    groups.Add(cmds)    ...    cmds.AddCommand(alpha)    cmds.AddCommand(cmdconfig.NewCmdConfig(f, clientcmd.NewDefaultPathOptions(), ioStreams))    cmds.AddCommand(plugin.NewCmdPlugin(f, ioStreams))    cmds.AddCommand(version.NewCmdVersion(f, ioStreams))    ...    return cmds}</code></pre><p>NewKubectlCommand 函数实例化了 cobra.Command 对象，templates.CommandGroups 定义了 kubectl 的 8 种命令类别，通过 cmds.AddCommand 添加命令类别。<br>get 命令的 Command 定义如下：</p><pre><code>func NewCmdGet (parent string, f cmdutil.Factory, streams genericclioptions.IOStreams) *cobra.Command {    o := NewGetOptions(parent, streams)    cmd := &amp;cobra.Command {        Use: "get ...",        DisableFlagsInUseLine: true,        Short: ...        Long: ...        Example: getExample,        Run: func(cmd *cobra.Command, args []string) {            cmdutil.CheckErr(o.Complete(f, cmd, args))            cmdutil.CheckErr(o.Validate(cmd))            cmdutil.CheckErr(o.Run(f, cmd, args))        },        SuggestFor: []string{"list", "ps"},    }    ...} </code></pre><p>在 cobra.Command 对象中， Use, Short, Long 和 Example 包含描述命令的信息，最重要的是定义 Run 执行函数，</p><blockquote><p>Cobra 中 Run 函数家族成员有很多，执行顺序有 PersistentPreRun -&gt; PreRun -&gt; Run -&gt; PostRun -&gt; PersistentPostRun。具体参考 cobra.Command 中的结构体定义。</p></blockquote><h3 id="为-get-命令添加命令行参数"><a href="#为-get-命令添加命令行参数" class="headerlink" title="为 get 命令添加命令行参数"></a>为 get 命令添加命令行参数</h3><p>get 命令行参数比较多，这里以 –all -namespaces 参数为例:</p><pre><code>func NewCmdGet (parent string, f cmdutil.Factory, streams genericclioptions.IOStreams) *cobra.Command {    ...    cmd.Flags().BoolVarP(&amp;o.AllNamespaces // 接受命令行参数的变量, "all-namespaces" // 指定命令行参数的名称, "A" // 指定命令行参数的名称简写, o.AllNamespaces // 设置命令行参数的默认值, "If present, list the requested object(s) across all namespqaces.Namespace in current context is ignored even if specified with --namespace." // 设置命令行参数的提示信息)    ...}</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre><code>func main() {    command := cmd.NewDefaultKubectlCommand()    ...    if err := command.Execute(); err != nil {        fmt.Printf(os.Stderr, "%v\n", err)        os.Exit()    }}</code></pre><p>kubectl 的 main 函数中定义了执行函数 command.Execute，原理是对命令中的所有参数解析出 Command 和 Flag，把 Flag 作为参数传递给 Command 并执行。</p><pre><code>cmd, flags, err = c.Find(args)...err = cmd.execute(flags)</code></pre><p>args 数组中包含所有命令行参数，通过 c.Find 解析出 cmd 和 flags，然后通过 cmd.execute 执行命令中定义的 Run 执行函数。</p><h2 id="创建资源对象的过程"><a href="#创建资源对象的过程" class="headerlink" title="创建资源对象的过程"></a>创建资源对象的过程</h2><p>内部运行原理是，客户端和服务端进行一次 HTTP 请求的交互。创建资源对象的流程可分为：</p><ol><li>实例化 Factory 接口，通过 Builder 和 Visitor 将资源对象描述文件（xxx.yaml）文本格式转换成资源对象。</li><li>将资源对象以 HTTP 请求的方式发送给 kube-apiserver，并得到响应结果。</li><li>最终根据 Visitor 匿名函数集的 errors 判断是否成功创建了资源对象。</li></ol><h3 id="编写资源对象描述文件"><a href="#编写资源对象描述文件" class="headerlink" title="编写资源对象描述文件"></a>编写资源对象描述文件</h3><p>Kubernetes 系统的资源对象可以使用 JSON 或 YAML 文件来描述,一般使用 YAML 文件居多。</p><pre><code>apiVersion: v1       #必选，版本号，例如v1kind: Pod       #必选，Podmetadata:       #必选，元数据  name: string       #必选，Pod名称  namespace: string    #必选，Pod所属的命名空间  labels:      #自定义标签    - name: string     #自定义标签名字  annotations:       #自定义注释列表    - name: stringspec:         #必选，Pod中容器的详细定义  containers:      #必选，Pod中容器列表  - name: string     #必选，容器名称    image: string    #必选，容器的镜像名称    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令    args: [string]     #容器的启动命令参数列表    workingDir: string     #容器的工作目录    volumeMounts:    #挂载到容器内部的存储卷配置    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符      readOnly: boolean    #是否为只读模式    ports:       #需要暴露的端口库号列表    - name: string     #端口号名称      containerPort: int   #容器需要监听的端口号      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同      protocol: string     #端口协议，支持TCP和UDP，默认TCP    env:       #容器运行前需设置的环境变量列表    - name: string     #环境变量名称      value: string    #环境变量的值    resources:       #资源限制和请求的设置      limits:      #资源限制的设置        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数      requests:      #资源请求的设置        cpu: string    #Cpu请求，容器启动的初始可用数量        memory: string     #内存清楚，容器启动的初始可用数量    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可      exec:      #对Pod容器内检查方式设置为exec方式        command: [string]  #exec方式需要制定的命令或脚本      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port        path: string        port: number        host: string        scheme: string        HttpHeaders:        - name: string          value: string      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式         port: number       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次       successThreshold: 0       failureThreshold: 0       securityContext:         privileged:false    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定    - name: string    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络    volumes:       #在该pod上定义共享存储卷列表    - name: string     #共享存储卷名称 （volumes类型有很多种）      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部        scretname: string          items:             - key: string          path: string      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部        name: string        items:        - key: string</code></pre><p>通过 kubectl create 命令与 kube-apiserver 交互并创建资源对象。（kubectl create -f XXX.yaml）</p><h3 id="实例化-Factory-接口"><a href="#实例化-Factory-接口" class="headerlink" title="实例化 Factory 接口"></a>实例化 Factory 接口</h3><p>在执行每一个 kubectl 命令之前，都需要实例化 cmdutil Factory 接口对象的操作，Factory 是一个通用对象，它提供了与 kube-apiserver 的交互方式，以及验证资源对象等方法。cmdutil Factory 接口代码示例如下：</p><pre><code>f := cmdutil.NewFactory(matchVersionKubeConfigFlags)type Factory interface {    DynamicClient()    // 动态客户端    KubernetesClientSet()    // ClientSet客户端    RESTClient()    // RESTClient客户端    NewBuilder()    // 实例化 Builder,Builder 用于将命令行获取的参数转换成资源对象    Validator(...)    // 验证资源对象    ...}</code></pre><h3 id="Builder-构建资源对象"><a href="#Builder-构建资源对象" class="headerlink" title="Builder 构建资源对象"></a>Builder 构建资源对象</h3><p>Builder 用于将命令行获取的参数转换成资源对象，它实现了一种通用的资源对象转换功能。<br>Builder 结构体保存了命令行获取的各种参数，并通过不同函数处理不同参数，将其转换成资源对象。</p><pre><code>r := f.NewBuilder().    Unstructured().    Schema(schema).    ContinueOnError().    NamespaceParam(cmdNamespace).DefaultNamespace().    FilenameParam(enforceNamespace, &amp;o.FilenameOptions).    LabelSelectorParam(o.Selector).    Flatten().    Do()err = r.Err()if err != nil {    return err}</code></pre><p>首先通过 f.NewBuilder 实例化 Builder 对象，通过函数 Unstructured 等对参数赋值和初始化，将参数保存到 Builder 对象中，最后通过 Do 函数完成对资源的创建。</p><p>其中，FilenameParam 函数用于识别 kubectl create 命令行参数是通过哪种方式传入资源对象描述文件：</p><ol><li>标准输入 stdin</li><li>本地文件</li><li>网络文件</li></ol><p>Do 函数返回 <strong>Result 对象</strong>，Result 对象的 <strong>info 字段</strong>保存了 RESTClient 与 kube-apiserver 交互产生的结果，可以通过 Result 对象的 infos 或 Object 方法来获取执行结果，而 Result 对象中的结果，是由 <strong>Visitor 执行产生</strong>。</p><h3 id="Visitor-多层匿名函数嵌套"><a href="#Visitor-多层匿名函数嵌套" class="headerlink" title="Visitor 多层匿名函数嵌套"></a>Visitor 多层匿名函数嵌套</h3><p>Result 对象中的结果，是由 <strong>Visitor</strong> 执行并产生，Visitor 接口定义如下：</p><pre><code>type Visitor interface {    Visit(VisitorFunc) error}type VisitorFunc func(*info, error) error// 该匿名函数则生成或处理 Info 结构</code></pre><p>在 Kubernetes 源码中，Visitors 被设计为可以多层嵌套（即多层匿名函数嵌套，使用一个 Visitor 嵌套另一个 Visitor）。</p><p>Visitor Example 代码示例如下：</p><pre><code>type Visitor interface {    Visit(VisitorFunc) error}type VisitorFunc func() errortype VisitorList []Visitorfunc (l VisitorList) Visit(fn VisitorFunc) error {    for i := range l {        if err := l[i].Visit(func() error {            fmt.Println("In VisitorList before fn")            fn()            fmt.Println("In VisitorList after fn")            return nil        }); err != nil {            return err        }    }    return nil}type Visitor1 struct {}func (v Visitor1) Visit(fn VisitorFunc) error {    fmt.Println("In Visitor1 before fn")    fn()    fmt.Println("In Visitor1 after fn")    return nil}type Visitor2 struct {    visitor Visitor}func (v Visitor2) Visit(fn VisitorFunc) error {    v.visitor.Visit(func() error {        fmt.Println("In Visitor2 before fn")        fn()        fmt.Println("In Visitor2 after fn")        return nil    })    return nil}type Visitor3 struct {    visitor Visitor}func (v Visitor3) Visit(fn VisitorFunc) error {    v.visitor.Visit(func() error {        fmt.Println("In Visitor3 before fn")        fn()        fmt.Println("In Visitor3 after fn")        return nil    })    return nil}func main() {    var visitor Visitor    var visitors []Visitor    visitor = Visitor1{}    visitors = append(visitors, visitor)    visitor = Visitor2{VisitorList(visitors)}    visitor = Visitor3{visitor}    visitor.Visit(func() error {        fmt.Println("In visitFunc")        return nil    })}</code></pre><ul><li>其中定义了 Visitor 接口，增加了 VisitorList 对象，该对象相当于多个 Visitor 匿名函数的集合，另外增加了 3 个 Visitor 的类，分别实现 Visit 方法，该方法的 VisitorFunc 函数在执行之前和执行之后分贝输出 print 信息。</li><li>在 main 函数中，首先将 Visitor1 嵌入 VisitorList 中，VisitorList 是 Visitor 的集合，可存放多个 Visitor。然后将 VisitorList 嵌入 Visitor2 中，接着将 Visitor2 嵌入 Visitor3 中，最终形成 Visitor3{Visitor2{VisitorList{Visitor1}}} 的嵌套关系。</li></ul><p>Kubernetes 源码中的 Visitor，代码示例如下：</p><pre><code>type EagerVisitorList []Visitor// 当遍历执行 Visitor 时，如果遇到错误，则保留错误信息，继续遍历执行下一个 Visitor，最后一起返回所有错误。type VisitorList []Visitor// 当遍历执行 Visitor 时，如果遇到错误，则立刻返回。</code></pre><p>Kubernetes Visitor 中存在多种实现方法，不同实现方法的作用不同，最终通过 Visitor 的 error 信息为空判断创建资源请求执行成功。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> kubectl 命令行交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes核心数据结构2.0</title>
      <link href="kubernetes-data-structure-2/"/>
      <url>kubernetes-data-structure-2/</url>
      
        <content type="html"><![CDATA[<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h3><p>预先知道数据结构的数据类型是结构化数据。要使用这种数据，需要创建一个 struct 数据结构，并且可以通过 Go 语言的 json 库进行反序列化操作。</p><h3 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h3><p>无法预知数据结构的数据类型或属性名称不确定的数据类型是非结构化数据，其无法通过构建预定的 struct 数据结构来序列化或反序列化数据。</p><p>可以通过如下结构来解决问题：</p><pre><code>var result map[string]interface{}</code></pre><blockquote><p>interface {}类型对应值，可以是任何类型，使用 interface 字段时，通过 Go 语言断言的方式进行类型转换。</p></blockquote><pre><code>if description, ok := result["description"].(string); ok {    fmt.Println(description)}</code></pre><h2 id="Scheme-资源注册表"><a href="#Scheme-资源注册表" class="headerlink" title="Scheme 资源注册表"></a>Scheme 资源注册表</h2><p>Kubernetes 系统拥有众多资源，每一种资源就是一个资源类型，这些资源类型需要有统一的注册、存储、查询、管理等机制。目前 Kubernetes 系统中的所有资源类型都已注册到 Scheme 资源注册表中，其是一个内存型的资源注册表。</p><p>Scheme 资源注册表支持如下两种类型：</p><ul><li><p>UnversionedType: 无版本资源类型，这是早期 Kubernetes 系统中的概念，它主要应用于某些没有版本的资源类型，该类型的资源对象并不需要进行转换。</p></li><li><p>KnownType: 目前 Kubernetes 最常用的资源类型，也可称其为“拥有版本的资源类型”。</p></li></ul><h3 id="Scheme-资源注册表数据结构"><a href="#Scheme-资源注册表数据结构" class="headerlink" title="Scheme 资源注册表数据结构"></a>Scheme 资源注册表数据结构</h3><p>Scheme 资源注册表数据结构主要由4个map结构组成，分别是：</p><pre><code>type Scheme struct {    gvkToType map[scheme.GroupVersionKind]reflect.Type    // 存储 GVK 与 Type 的映射关系    typeToGVK map[reflect.Type][]scheme.GroupVersionKind    // 存储 Type 与 GVK 的映射关系，一个 Type 会对应一个或多个 GVK    unversionedTypes map[reflect.Type]scheme.GroupVersionKind    // 存储 UnversionedType 与 GVK 的映射关系    unversionedKinds map[string]reflect.Type    // 存储 Kind 名称与 UnversionedType 的映射关系 }</code></pre><blockquote><p>这些映射关系可以实现高效的正向和反向检索。</p></blockquote><p>Scheme 资源注册表在 Kubernetes 系统体系中属于非常核心的数据结构，Scheme Example 代码示例如下：</p><pre><code>func main() {    // KnownType external    coreGV := schema.GroupVersion{Group:"", Version: "v1"}    extensionsGV := schema.GroupVersion{Group: "extensions", Version: "v1beta1"}    // KnownType internal    coreInternalGV := schema.GroupVersion{Group: "", Version: runtime.APIVersionInternal}    // UnversionedType     Unversioned := schema.GroupVersion{Group: "", Version: "v1"}    schema := runtime.NewScheme()    scheme.AddKnownTypes(coreGV, &amp;corev1.Pod{})    scheme.AddKnownTypes(extensionsGV, &amp;appsv1.DaemonSet{})    scheme.AddKnownTypes(coreInternalGV, &amp;corev1.Pod{})    scheme.AddUnversionedTypes(Unversioned, &amp;metav1.Status{})    // 注册资源类型到 Scheme 资源注册表有以上两种方式}</code></pre><ul><li><p>GVK 在 Scheme 资源注册表中以 <group>/<version>,Kind=<kind>的形式存在，其中对于 Kind 字段，在注册时如果不指定该字段的名称，那么默认使用类型的名称，通过 reflect 机制获取资源类型的名称。</kind></version></group></p></li><li><p>资源类型在 Scheme 资源注册表中以 Go Type（通过 reflect 机制获取）形式存在。</p></li></ul><blockquote><p>需要注意的是，UnversionecdType 类型的对象在通过 scheme.AddUnversionedTypes 方法注册时，会同时存在4个 map 结构中，代码示例如下：</p></blockquote><pre><code>func (s *Scheme) AddUnversionedTypes(version schema.GroupVersion, types ...Object) {    ...    s.AddKnownTypes(version, types...)    // 1    for _, obj := range types {        t := reflect.TypeOf(obj).Elem()        gvk := version.WithKind(t.Name())        // 2        s.unversionedTypes[t] = gvk        // 3        ...        s.unversionedKinds[gvk.Kind] = t        // 4    }}</code></pre><h3 id="资源注册表注册方法"><a href="#资源注册表注册方法" class="headerlink" title="资源注册表注册方法"></a>资源注册表注册方法</h3><p>在 Scheme 资源注册表中，不同的资源类型使用的注册方法不同，分别如下：</p><ul><li>scheme.AddUnversionedTypes: 注册 UnversionedType 资源类型</li><li>scheme.AddKnownTypes: 注册 KnownType 资源类型</li><li>scheme.AddKnownTypesWithName: 注册 KnownType 资源类型，须指定资源的 Kind 资源种类名称</li></ul><p>举例 scheme.AddKnownTypes 如下:</p><pre><code>func (s *Scheme) AddKnownTypes(gv schema.GroupVersion,types ...object){    s.addObservedVersion(gv)    for _, obj := range types {        t := reflect.Typeof(obj)        // 通过 reflect 机制获取资源类型的名称作为资源种类名称        if t.Kind() != reflect.Ptr {            panic("All types must be pointers to structs.")        }        t = t.Elem()        s.AddKnownTypeWithName(gv.WithKind(t.Name()), obj)        // 调用这种注册方法    }}</code></pre><h2 id="Codec-编解码器"><a href="#Codec-编解码器" class="headerlink" title="Codec 编解码器"></a>Codec 编解码器</h2><ul><li><p>Serializer: 序列化器，包含序列化操作与反序列化操作</p></li><li><p>Codec: 编解码器，包含编码器和解码器。</p><blockquote><p>编解码器指的是可以表示数据的任何格式，或者将数据转换为特定格式的过程。</p></blockquote></li></ul><pre><code>type Encoder interface{}// 编码器type Decoder interface{}// 解码器type Serializer interface{    Encoder    Decoder}// 只要实现了 Encoder 与 Decoder 方法的数据结构，就是序列化器type Codec Serialier</code></pre><p>Codec 编解码器包含3中序列化器：</p><ol><li>jsonSerializer: JSON 格式序列化/反序列化器。</li><li>yamlSerializer: YAML 格式序列化/反序列化器。</li><li>protobufSerializer: Protobuf 格式序列化/反序列化器。<blockquote><p>都使用 ContentType 作为标识。</p></blockquote></li></ol><h3 id="Codec-编解码实例化"><a href="#Codec-编解码实例化" class="headerlink" title="Codec 编解码实例化"></a>Codec 编解码实例化</h3><p>Codec 编解码器通过 NewCodecFactory 函数实例化，NewCodecFactory -&gt; newSerializersForSchem。<br>分别都是通过 json.NewSerializer/json.NewYAMLSerializer/protobuf.NewSerializer 函数进行实例化。</p><h3 id="json-和-yaml-序列化器"><a href="#json-和-yaml-序列化器" class="headerlink" title="json 和 yaml 序列化器"></a>json 和 yaml 序列化器</h3><ul><li><p>json 序列化器使用 Go 语言标准库 encoding/json 来实现序列化和反序列化。</p></li><li><p>yaml 序列化器使用第三方库 gopkg.in/yaml.v2 来实现序列化和反序列化。</p></li><li><p>json 和 yaml 序列化器共享同一个数据结构，通过 yaml 字段区分，如果该字段为 true 则使用 yaml 序列化器，否则为使用 json 序列化器。</p></li><li><p>如果是 yaml 格式，第一步通过 caseSensitiveJsonIterator.Marshal 函数将资源对象转换为 Json 格式，第二步通过 yaml.JSONToYAML 将 JSON 格式转换为 YAML 格式并返回数据。</p></li><li><p>如果是 JSON 格式，则通过 Go 语言标准库将资源对象转换为 JSON 格式。其中如果 pretty 参数开启的话，则通过 caseSensitiveJsonIterator.MarshalIndent 函数优化 JSON 格式。</p><blockquote><p>caseSensitiveJsonIterator 函数实际封装了 github.com/json-iterator/go 第三方库，json-iterator 有如下几个好处。</p><ol><li>json-iterator 支持区分大小写。</li><li>json-iterator 性能更优。</li><li>json-iterator 100% 兼容 Go 语言标准库。</li></ol></blockquote></li></ul><h3 id="protobufSerializer-序列化器"><a href="#protobufSerializer-序列化器" class="headerlink" title="protobufSerializer 序列化器"></a>protobufSerializer 序列化器</h3><p>protobuf 序列化器使用 proto 库来实现序列化和反序列操作。</p><ul><li>前缀有 magic-number 特殊标识。</li></ul><h2 id="Converter-资源版本转换器"><a href="#Converter-资源版本转换器" class="headerlink" title="Converter 资源版本转换器"></a>Converter 资源版本转换器</h2><p>可以通过 kubectl convert 命令进行资源版本转换：</p><pre><code>$ kubectl convert -f v1beta1Deployment.yaml --output-version=apps/v1apiVersion: apps/v1kind: Deployment </code></pre><p>kubernetes 系统中一个资源支持多个资源版本，每个资源版本都支持其他资源版本的转换，随着资源版本的增加，资源版本转换的定义会越来越多，这样处理起来非常麻烦。<br>因此 kubernetes 通过内部版本机制实现资源版本转换。</p><ul><li>当需要在两个资源版本之间转换时，Converter 资源版本转换器先将第一个资源版本转换为 __internal 内部版本，再转换为相应的资源版本。</li><li>每个资源只要能支持内部版本，就能与其他任何资源版本进行间接的资源版本转换。</li></ul><h3 id="Converter-转换器数据结构"><a href="#Converter-转换器数据结构" class="headerlink" title="Converter 转换器数据结构"></a>Converter 转换器数据结构</h3><p>Converter 转换器数据结构主要存放转换函数（即 Conversion Funcs）。</p><pre><code>type Converter struct {    conversionFuncs          ConversionFuncs    // 默认转换函数    generatedConversionFuncs ConversionFuncs    // 自动生成的转换函数    ignoredConversions       map[typePair]stuct{}    // 若资源对象注册到此字段，则忽略此资源对象的转换操作    nameFunc                 func(t reflect.Type) string    // 在转换过程中其用于获取资源种类的名称    ...}type ConversionFuncs struct {    fns     map[typePair]reflect.Value    untyped map[typePair]ConversionFunc}type typePair struct {    source reflect.Type    dest   reflect.Type}type ConversionFunc func(a, b interface{}, scope Scope) error// 将资源对象 a 转换为资源对象 b，scope 定义了多次转换机制。</code></pre><h3 id="Converter-注册转换函数"><a href="#Converter-注册转换函数" class="headerlink" title="Converter 注册转换函数"></a>Converter 注册转换函数</h3><p>Converter 转换函数需要通过注册才能在 Kubernetes 内部使用，目前支持 5 个注册转换函数。</p><ol><li>注册忽略的资源类型。</li><li>注册多个 Conversion Func 转换函数。</li><li>注册单个 Conversion Func 转换函数。</li><li>注册自动生成的转换函数。</li><li>注册字段标签的转换函数。</li></ol><h3 id="Convert-资源版本转换原理"><a href="#Convert-资源版本转换原理" class="headerlink" title="Convert 资源版本转换原理"></a>Convert 资源版本转换原理</h3><p>Converter Example（将 Deployment 资源对象从 v1beta1 -&gt; v1） 代码示例如下：</p><pre><code>func main() {    // 第一部分：实例化一个空的 Scheme 资源注册表，将 v1beta1、v1的资源版本及内部版本的 Deployment 资源注册到 Scheme 资源注册表中。    scheme := runtime.NewScheme()    scheme.AddKnownTypes(appsv1beta1.SchemeGroupVersion, &amp;appsv1beta1.Deployment{})    scheme.AddKnownTypes(appsv1.SchemeGroupVerison, &amp;appsv1.Deployment{})    scheme.AddKnownTypes(apps.SchemeGroupVersion, &amp;appsv1.Deployment{})    metav1.AddToGroupVersion(scheme, appsv1beta1.SchemeGroupVersion)    metav1.AddToGroupVersion(scheme, appsv1.SchemeGroupVersion)    // 第二部分：实例化 v1beta1Deployment 资源对象，    v1beta1Deployment := &amp;appsv1beta1.Deployment{        TypeMeta: metav1.TypeMeta{            Kind:       "Deployment",            APIVersion: "apps/v1beta1",        }    }    // 通过 scheme.ConvertToVersion 将其转换为内部版本    // v1beta1 -&gt; __internal    objInternal, err := scheme.ConvertToVersion(v1beta1Deployment, apps.SchemeGroupVersion)    if err != nil {        panic(err)    }    fmt.Println("GVK", objinternal.GetObjectKind().GroupVersionKind().String())    // output:    // GVK: /, Kind =    // 通过 scheme.ConvertToVersion 转换为目标资源版本，并通过断言的方式来判断是否转换成功。    // __internal -&gt; v1    objV1, err := scheme.ConvertToVersion(objInternal, appsv1.SchemeGroupVersion)    if err != nil {        panic(err)    }    v1Deployment, ok := objV1.(*appsV1.Deployment)    if !ok {        panic("Got wrong type")    }    fmtPrintln("GVK: ", v1Deployment.GetObjectKind().GroupVersionKind().String())    // output:    // GVK: apps/v1, Kind = Deployment }</code></pre><p>Scheme 资源注册表可以通过两种方式进行版本转换：</p><ol><li>将传入的资源对象转换成目标资源版本之前，会将资源对象深复制一份后再执行转换操作，相当于安全的内存对象转换操作。</li><li>在资源对象转换的过程中，不会深复制资源对象，而是直接对原资源对象进行转换操作，尽可能高效地实现转换，是非安全的内存对象转换操作。</li></ol><p>下面是 Converter 转换器流程：</p><p><img src="../image/Converter%E8%BD%AC%E6%8D%A2%E5%99%A8.jpg" alt="Convert转换器流程图"></p><ol><li>获取传入的资源对象的反射类型</li></ol><p>因为在 Scheme 资源注册表中是以反射类型注册资源的</p><pre><code>t = reflect.Typeof(in).Elem()</code></pre><ol start="2"><li>从资源注册表中查找到传入的资源对象的 GVK </li></ol><pre><code>kinds, ok := s.typeToGVK[t]if !ok || len(kinds) == 0 {    return nil, NewNotRegisteredErrForType(s.schemeName, t)}</code></pre><ol start="3"><li>从多个 GVK 中选出与目标资源对象相匹配的 GVK</li></ol><p>这里有个优缺点，转换过程是相对耗时的，大量的相同资源之间进行版本转换的耗时会比较长。因此如果目标资源对象的 GVK 在可转换的 GVK 列表中，则直接将传入的资源对象的 GVK 设置为目标资源对象的 GVK，而无须执行转换操作，缩短部分耗时。</p><pre><code>gvk, ok := target.KindForGroupVersionKinds(kinds)...for _, kind := range kinds {    if gvk == kind {        retrurn copyAndSetTargetKind(copy, in, gvk)    }}</code></pre><ol start="4"><li>判断传入的资源对象是否属于 Unversioned 类型</li></ol><p>属于该类型的资源对象并不需要进行转换操作，而是直接将传入的资源对象的 GVK 设置为目标资源对象的 GVK。</p><pre><code>if unversionedKind, ok := s.unversionedTypes[t]; ok {    ...    return copyAndSetTargetKind(copy, in, unversionedKind)}</code></pre><ol start="5"><li>执行转换操作</li></ol><p>在执行转换操作之前，先判断是否需要对传入的资源对象执行深复制操作，然后通过 s.converter.Convert 转换函数执行转换操作，代码示例如下：</p><pre><code>if copy {    in = in.DeepCopyObject()}if err := s.converter.Convert(in, out, flags, meta); err != nil {    return nil, err}</code></pre><p>实际的转换函数是通过 doConversion 函数执行的：</p><pre><code>func (c *Converter) doConversion(src, dest interface{}, flags FieldMatchingFlags, meta *Meta, f conversionFunc) error {    pair := typePair{reflect.TypeOf(src), reflect.TypeOf(dest)}    ...    // 若在默认转换函数列表，查找出 pair 对应的转换函数执行并返回    if fn, ok := c.conversionFuncs.untyped[pair]; ok {        return fn(src, dest, scope)    }    // 若在自动生成的转换函数列表，查找出 pair 对应的转换函数执行并返回    if fn, ok := c.generatedConversionFuncs.untyped[pair]; ok {        return fn(src, dest, scope)    }    // 如果不在以上两个列表中，则使用 doConversion 函数传入的转换函数（即 f），调用 f 之前，需要将 src 与 dest 资源对象通过 EnforcePtr 函数取指针的值。    // 因为 doConversion 函数传入的转换函数接收的是非指针资源对象。    dv, err := EnforcePtr(dest)    sv, err := EnforcePtr(src)    ...    return f(sv, dv, scope)}</code></pre><ol start="6"><li>设置转换后资源对象的 GVK </li></ol><p>前面的 Converter Example 代码示例的第二部分中，将 v1beta1 资源版本转换为内部版本，得到转换后资源对象的 GVK 为 ”/,Kind=“，原因在于 setTargetKind 函数，转换操作执行完成后，通过 setTargetKind 函数设置转换后资源对象的 GVK，判断当前资源对象是否是内部版本，是的话，设置 GVK 为 scheme.GroupVersionKind{}。</p><pre><code>setTargetKind(out, gvk)func setTargetKind(obj Object, kind schema.GroupVersionKind) {    if kind.Version == APIVersionInternal {        obj.GetObjectKind().SetGroupVersionKind(scheme.GroupVersionKind{})        return    }    obj.GetObjectKind().SetGroupVersionKind(kind)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubernetes数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes核心数据结构1.0</title>
      <link href="kubernetes-he-xin-shu-ju-jie-gou-1-0/"/>
      <url>kubernetes-he-xin-shu-ju-jie-gou-1-0/</url>
      
        <content type="html"><![CDATA[<h2 id="Group、Version、Resource核心数据结构"><a href="#Group、Version、Resource核心数据结构" class="headerlink" title="Group、Version、Resource核心数据结构"></a>Group、Version、Resource核心数据结构</h2><p>在整个 Kubernetes 体系架构中，资源是 Kubernetes 最重要的概念，它本质上是一个资源控制系统————注册、管理、调度资源并维护资源的状态。</p><p>Kubernetes 将资源进行分组和版本化，形成 Group、Version、Resource。具体机构图如下：</p><p><img src="../image/kubernetes%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="kubernetes核心数据结构图"></p><ul><li><p>部分资源同时会拥有自己的子资源，例如，Deployment 资源拥有 Status 子资源。</p></li><li><p>完整的表现形式为 <group>/<version>/<resource>/<subresource></subresource></resource></version></group></p></li><li><p>外部版本用于对外暴露给用户请求的接口所使用的资源对象。</p></li><li><p>内部版本不对外暴露，仅在 kubernetes api server 内部使用。</p></li><li><p>kubernetes 的每个资源可使用 metav1.APIResource 结构进行描述，它描述资源的基本信息，例如资源名称，资源所属 命名空间，资源种类，资源可操作的方法列表。</p></li></ul><pre><code>resourceList := []*metav1.APIResourceList{    {        GroupVersion: "v1",        APIResources: []metav1.APIResource{            {                Name: "pods", # 资源不存在资源组时                Namespaced: true,                Kind: "Pod",                Verbs: []string{"get", "list", "delete", "deletecollection", "create", "update", "patch", "watch"},            },            {                Name: "services",                Namespaced: true,                Kind: "Service",                Verbs: []string{"get", "list", "delete", "deletecollection", "create", "update", "patch", "watch"},            },        },    },    {        GroupVersion: "apps/v1", # 同时存在资源组和版本        APIResources: []metav1.APIResource{            {                Name: "deployments",                Namespaced: true,                Kind: "Deployment",                Verbs: []string{"get", "list", "delete", "deletecollection", "create", "update", "patch", "watch"},            },        },    }}</code></pre><blockquote><p>可以通过 Group、Version、Resource 结构来明确标识一个资源的资源组名称，资源版本及资源名称。简称 GVR。<br>常见的资源结构如下： GVR, GV, GR, GVK, GV, GK, GVS。</p></blockquote><h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><pre><code>type APIGroup struct {    Name string    // 资源组名称    Versions []GroupVersionForDiscovery    // 资源组下所支持的资源组版本    PreferredVersion GroupVersionForDiscovery    // 首选版本}</code></pre><ul><li><p>拥有组名的资源组：其表现形式为 <group>/<version>/<resouce></resouce></version></group></p><blockquote><p>拥有组名的资源组的 HTTP PATH 以 /apis 为前缀，其表现形式为 /apis/<group>/<version>/<resource> </resource></version></group></p></blockquote></li><li><p>没有组名的资源组：被称为 Core Groups（即核心资源组）或 Legacy Groups，也可能被称为 GroupLess （即无组），其表现形式为 <version>/<resouce></resouce></version></p><blockquote><p>没有组名的资源组的 HTTP PATH 以 /api 为前缀，其表现形式为 /api/<version>/<resource></resource></version></p></blockquote></li></ul><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p>分为三种版本，依次迭代顺序为 Alpha -&gt; Beta -&gt; Stable</p><pre><code>type APIVersions struct {    Versions []string}// Versions: 所支持的资源版本列表</code></pre><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>一个资源被实例化后会表达为一个资源对象（即 Resource Object），所有资源对象都是 Entity（实体）。</p><p>Kubernetes 目前支持的两种实体：</p><ul><li>持久性实体（Persistent Entity）:在资源对象被创建够， Kubernetes 会持久确保该资源对象存在。大部分对象属于持久性实体，例如 Deployment 资源对象。</li><li>短暂性实体（Ephemeral Entity）:在资源对象被创建后，如果出现故障或调度失败，不会重新创建该资源对象，例如 Pod 资源对象。</li></ul><pre><code>type APIResource struct {    Name string    // 资源名称    SingularName string    // 资源的单数名称，它必须由小写字母组成，默认使用资源种类的小写形式进行命名。    Namespaced bool    // 资源是否拥有所属命名空间    Group string    Version string    Kind string    Verbs Verbs    ShortNames []string    // 资源的简称}</code></pre><h3 id="资源外部版本和内部版本"><a href="#资源外部版本和内部版本" class="headerlink" title="资源外部版本和内部版本"></a>资源外部版本和内部版本</h3><ul><li><p>External Object: 外部版本用于对外暴露给用户请求的接口所使用的资源对象，用户通过 YAML/JSON 格式的描述文件创建资源对象时，所使用的是外部版本的资源对象，外部版本的资源对象通过资源版本（Alpha, Beta, Stable）进行标识。</p></li><li><p>Internal Object: 内部版本不对外暴露，仅在 kubernetes api server 内部使用，内部版本用于多资源版本的转换。内部版本资源对象通过 runtime.APIVersionInternal (即_internal)进行标识。</p><blockquote><p>资源版本（如 v1beta1,v1等）与外部版本/内部版本概念不同，拥有资源版本的资源属于外部资源，拥有 runtime.APIVersionInternal 标识的资源属于内部版本</p></blockquote></li><li><p>资源的外部版本和内部版本是需要相互转换的，而用于转换的函数需要事先初始化到资源注册表（Scheme）中，多个外部版本之间的资源进行相互转换，都需要通过内部版本进行中转。<strong>这也是 Kubernetes 能实现多资源版本转换的关键</strong></p></li><li><p>资源的外部版本和内部版本的代码定义也不太一样，外部版本的资源需要对外暴露给用户请求的接口，所以资源代码定义了 JSON/Proto Tags，而内部版本的资源不对外暴露，所以没有任何 Tags 定义。</p></li></ul><h3 id="资源代码定义"><a href="#资源代码定义" class="headerlink" title="资源代码定义"></a>资源代码定义</h3><p>Kubernetes 内部版本和外部版本的资源代码结构并不相同。</p><ul><li>资源的内部版本定义了所支持的资源类型（types.go）、资源验证方法（validation.go）、资源注册至资源注册表的方法（install/install.go）等。</li><li>资源的外部版本定义了资源的转换方法（conversion.go）、资源的默认值（defaults.go）等。</li><li>外部版本与内部版本资源类型相同，都通过 register.go 代码文件定义所属的资源组和资源版本，外部版本资源对象通过资源版本（Alpha、Beta、Stable）标识。</li></ul><h3 id="将资源注册到资源注册表中"><a href="#将资源注册到资源注册表中" class="headerlink" title="将资源注册到资源注册表中"></a>将资源注册到资源注册表中</h3><p>在每一个 Kubernetes 资源组目录中，都拥有一个 install/install.go 代码文件，它负责将资源信息注册到资源注册表（Scheme）中。</p><ul><li><p>legancyschema.Scheme 是 kube-apiserver 组件的全局资源注册表，kubernetes 的所有资源信息都交给资源注册表统一管理。</p></li><li><p>core.AddToScheme: 函数注册 core 资源组内部版本的资源。</p></li><li><p>v1.AddToScheme: 函数注册 core 资源组外部版本的资源。</p></li><li><p>scheme.SetVersionPriority: 函数注册资源组的版本顺序，如有多个资源版本，排在最前面的为资源首选版本。</p></li></ul><h3 id="资源操作方法"><a href="#资源操作方法" class="headerlink" title="资源操作方法"></a>资源操作方法</h3><p>在 kubernetes 系统中，针对每一个资源都有一定的操作方法（即 Verbs）。</p><ul><li><p>目前支持8中操作：create, delete, deletecollection, get, list, patch, update, watch，这些操作可以分为四大类，分别属于对资源进行创建、删除、更新和查询。</p></li><li><p>要了解一个资源对象拥有哪些可操作的方法，需要查看与存储相关联的源码包 registry。</p></li></ul><h3 id="资源与命名空间"><a href="#资源与命名空间" class="headerlink" title="资源与命名空间"></a>资源与命名空间</h3><p>kubernetes 系统中默认内置了4个命名空间，分别如下：</p><ul><li>default: 默认的命名空间</li><li>kube-system: 所有由 kubernetes 系统创建的资源对象都会被分配给该命名空间</li><li>kube-public: 此命名空间下的资源对象可以被所有人访问</li><li>kube-node-lease: 此命名空间下存放来自节点的心跳记录</li><li>决定资源对象属于哪个命名空间，可通过资源对象的 ObjectMeta.Namespace 描述。</li></ul><h3 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h3><p>开发者通过 CustomResourceDefinitions（CRD）可以实现自定义资源，并将之添加到 Kubernetes 系统中。</p><p>kubernetes 资源可分为内置资源和自定义资源，它们都通过资源对象描述文件（Manifest File）进行定义。一个资源对象需要用5个字段来描述，这些字段定义在 YAML 或 JSON 文件中。</p><ul><li>apiVersion: 指定创建资源对象的资源组和资源版本</li><li>kind: 指定创建资源对象的种类</li><li>metadata: 描述创建资源对象的元数据信息，例如名称、命名空间等。</li><li>spec: 包含有关资源对象的核心信息，包括资源状态、副本数量、环境变量、卷等信息。</li><li>status: 包含有关正在运行的资源对象的信息。</li></ul><h2 id="runtime-Object-类型基石"><a href="#runtime-Object-类型基石" class="headerlink" title="runtime.Object 类型基石"></a>runtime.Object 类型基石</h2><p>kubernetes 上的所有资源对象实际上就是一种 Go 语言的 Struct 类型，相当于一种数据结构，它们都有一个共同的结构叫 runtime.Object。runtime.Object 被设计为 Interface 接口类型，作为资源对象的通用资源对象。</p><blockquote><p>例如： Pod 资源对象可以转换为 runtime.Object 通用资源对象，runtime.Object 通用资源对象也可以转换为 Pod 资源对象。</p></blockquote><ul><li>runtime.object 提供了两个方法，分别是 GetObjectKind 和 DeepCopyObject。</li></ul><ol><li>GetObjectKind: 设置并返回 GroupVersionKind</li><li>DeepCopyObject: 用于深复制当前资源对象并返回</li></ol><ul><li><p>Kubernetes 的每一个资源对象都嵌入了 metav1.TypeMeta 类型，该类型实现了 GetObjectKind 方法</p><pre><code>func main(){  pod := &amp;core.Pod{      TypeMeta: metav1.TypeMeta{          Kind: "Pod",      },      ObjectMeta: metav1.ObjectMeta{          Labels: map[string]string{"name": "foo"}      },  }  // 首先实例化 pod 资源   obj := runtime.Object(pod)   // 通过 runtime.Object 将 Pod 资源对象转换成通用资源对象   pod2, ok := obj.(*core.Pod)   // 通过断言的方式，将 obj 通用资源转换成 Pod 资源对象   if !ok {       panic("unexpected")   }   if !reflect.DeepEqual(pod, pod2) {       panic("unexpected")   }   // 最终通过反射来验证转换前和转换后的资源对象是否相等}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubernetes数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes构建过程</title>
      <link href="kubernetes-gou-jian-guo-cheng/"/>
      <url>kubernetes-gou-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><h3 id="举例5个代码生成器"><a href="#举例5个代码生成器" class="headerlink" title="举例5个代码生成器"></a>举例5个代码生成器</h3><table><thead><tr><th>代码生成器</th><th>说明</th></tr></thead><tbody><tr><td>conversion-gen</td><td>自动生成 Convert 函数的代码生成器，用于资源对象的版本转换函数</td></tr><tr><td>deepcopy-gen</td><td>自动生成 DeepCopy 函数的代码生成器，用于资源对象的深复制函数</td></tr><tr><td>defaulter-gen</td><td>自动生成 Defaulter 函数的代码生成器，用于资源对象的默认值函数</td></tr><tr><td>go-bindata</td><td>是一个第三方工具，它能够将静态资源文件嵌入 Go 语言中</td></tr><tr><td>openapi-gen</td><td>自动生成 OpenAPI 定义文件的代码生成器</td></tr></tbody></table><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>代码生成器通过 Tags(标签)来识别一个包是否需要生成代码及确定生成代码的方式，Kubernetes 提供的 Tags 可以分为如下两种，Tags 被定义在注释中。</p><h4 id="全局-Tags"><a href="#全局-Tags" class="headerlink" title="全局 Tags"></a>全局 Tags</h4><ul><li>定义在每个包的 doc.go文件中，对整个包中的类型自动生成代码</li><li>代码示例如下：</li></ul><pre><code>// +k8s:deepcopy-gen=package// +groupName=example.com</code></pre><p>该示例表示为包中的每个类型自动生成 DeepCopy 函数，其中// +groupName定义了资源组名称，资源组名称一般用域名形式表示</p><h4 id="局部-Tags"><a href="#局部-Tags" class="headerlink" title="局部 Tags"></a>局部 Tags</h4><ul><li>定义在 Go 语言的类型声明上方，只对指定的类型自动生成代码</li><li>代码示例如下：</li></ul><pre><code>// +genclient// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object// Pod...</code></pre><p>该代码示例局部 Tags 定义在 Pod 资源类型的上方，定义并执行两个代码生成器。</p><blockquote><p>Kubernetes 的 API 文档生成器会根据类型声明的注释信息生成文档，为了避免 Tags 信息出现在文档中，所以将 Tags 定义在注释的上方并空一行</p></blockquote><h4 id="deepcopy-gen-代码生成器"><a href="#deepcopy-gen-代码生成器" class="headerlink" title="deepcopy-gen 代码生成器"></a>deepcopy-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 DeepCopy 相关函数，这些函数可以有效地执行每种类型的深复制操作。</p><p>有如下几种 Tags 形式：</p><ul><li><p>为整个包生成 DeepCopy 相关函数：</p><pre><code>// +k8s:deepcopy-gen=package</code></pre></li><li><p>为单个类型生成 DeepCopy 相关函数：</p><pre><code>// +k8s:deepcopy-gen=true</code></pre></li><li><p>为整个包生成 DeepCopy 相关函数时，可以忽略单个类型：</p><pre><code>// +k8s:deepcopy-gen=false</code></pre></li><li><p>deepcopy-gen 会遍历包中所有类型，若类型为 types.Struct,则会为该类型生成深复制函数。</p></li></ul><h4 id="defaulter-gen-代码生成器"><a href="#defaulter-gen-代码生成器" class="headerlink" title="defaulter-gen 代码生成器"></a>defaulter-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 Defaulter 相关函数，这些函数可以为资源对象生成默认值。</p><ul><li>为拥有不同属性的类型生成不同的 Defaulter 相关函数，其 Tags 形式如下：</li></ul><pre><code>// +k8s:defaulter-gen=TypeMeta/ListMeta/ObjectMeta</code></pre><ul><li>defaulter-gen-input 说明当前包会依赖于指定的路径包，代码示例如下：</li></ul><pre><code>// +k8s:defaulter-gen-input=../../../vendor/k8s.io/api/rbac/v1</code></pre><ul><li>defaulter-gen 会遍历包中所有类型，若类型属性拥有以上三种特定类型，则为该类型生成 Defaulter 函数，并为其生成 RegisterDefaults 注册函数。</li></ul><h4 id="conversion-gen-代码生成器"><a href="#conversion-gen-代码生成器" class="headerlink" title="conversion-gen 代码生成器"></a>conversion-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 Convert 相关函数，这些函数可以为对象在内部和外部类型之间提供转换函数。</p><p>其 Tags 形式如下：</p><ul><li>为整个包生成 Convert 相关函数</li></ul><pre><code>// +k8s:conversion-gen=&lt;peer-pkg&gt;# &lt;peer-pkg&gt; 用于定义包的导入路径</code></pre><ul><li>为整个包生成 Convert 相关函数且依赖其他包时</li></ul><pre><code>// +k8s:conversion-gen-external-types=&lt;type-pkg&gt;# &lt;type-pkg&gt; 用于定义其他包的路径</code></pre><ul><li>在排除某个属性后生成 Convert 相关函数</li></ul><pre><code>// +k8s:conversion-gen=false</code></pre><ul><li>conversion-gen 会遍历包中所有类型，若类型为 types.Struct 且过滤掉了私有 Struct 类型，则为该类型生成 Convert 函数，并为该类型同时生成 RegisterConversions 注册函数</li></ul><h4 id="openapi-gen-代码生成器"><a href="#openapi-gen-代码生成器" class="headerlink" title="openapi-gen 代码生成器"></a>openapi-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 OpenAPI 定义文件，该文件用于 kube-apiserver 服务上的 OpenAPI 规范的生成。</p><ul><li>为特定类型或包生成 OpenAPI 定义文件时</li></ul><pre><code>// +k8s:openapi-gen=true</code></pre><ul><li>排除为特定类型或包生成 OpenAPI 定义时</li></ul><pre><code>// +k8s:openapi-gen=false</code></pre><ul><li>openapi-gen 会遍历包中所有类型，若类型为 types.Struct 并忽略其他类型，则为 types.Struct 类型生成 OpenAPI 定义文件</li></ul><h4 id="go-bindata-代码生成器"><a href="#go-bindata-代码生成器" class="headerlink" title="go-bindata 代码生成器"></a>go-bindata 代码生成器</h4><p>给定一个静态资源目录路径作为输入源，go-bindata 可以为其生成 go 文件</p><h2 id="代码生成过程"><a href="#代码生成过程" class="headerlink" title="代码生成过程"></a>代码生成过程</h2><p>前面所提到的五种代码生成过程如下图所示</p><p><img src="../image/k8s%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt="代码生成过程"></p><ul><li>.todo 文件相当于临时文件，用来存放被 Tags 标记过的包。通过 shell 的 grep 命令可以将所有代码包中被 Tags 标记过的包目录记录在 .todo 文件中，这样可以方便记录哪些包需要使用代码生成功能。</li></ul><h2 id="gengo-代码生成核心实现"><a href="#gengo-代码生成核心实现" class="headerlink" title="gengo 代码生成核心实现"></a>gengo 代码生成核心实现</h2><p>Kubernetes 的代码生成器都是在 k8s.io/gengo 包的基础上实现的，代码生成器都会通过一个输入包路径（–input-dirs）参数，根据 gengo 的词法分析、抽象语法树等操作，最终生成代码并输出（–output-file-base），gengo 代码目录结构说明如下：</p><ul><li><p>args: 代码生成器的通用 flags 参数。</p></li><li><p>examples: 包含 deepcopy-gen、defaulter-gen、import-boss、set-gen等代码生成器的生成逻辑。</p></li><li><p>generator: 代码生成器通用接口 Generator。</p></li><li><p>namer: 命名管理，支持创建不同类型的名称。例如，根据类型生成名称，定义 type foo string，能够生成 func FooPrinter(f *foo){Print(string(*f))}</p></li><li><p>parser: 代码解析器，用来构造抽象语法树。</p></li><li><p>types: 类型系统，用于数据类型的定义及类型检查算法的实现。</p></li></ul><h3 id="代码生成逻辑与编译器原理"><a href="#代码生成逻辑与编译器原理" class="headerlink" title="代码生成逻辑与编译器原理"></a>代码生成逻辑与编译器原理</h3><p><img src="../image/gengo%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86.jpg" alt="gengo代码生成原理"></p><ul><li><p>Gather The Info: 收集 Go 语言源码文件信息及内容</p></li><li><p>Lexer/Parser: 通过 Lexer 词法分析器进行一系列词法分析</p></li><li><p>AST Generator: 生成抽象语法树</p></li><li><p>Type Checker: 对抽象语法树进行类型检查</p></li><li><p>Code Generation: 生成代码，将抽象语法树转换为机器代码</p></li></ul><h3 id="收集-Go-包信息"><a href="#收集-Go-包信息" class="headerlink" title="收集 Go 包信息"></a>收集 Go 包信息</h3><ul><li>采用 go/build 工具，构建标签机制来构建约束条件，例如看代码时常看到类似于//+build linux darwin 的包注释信息，这就是 Go 语言编译时的约束条件，其也被称为条件编译。</li></ul><blockquote><p>Go 语言的条件编译有两种定义方法：</p><ul><li>构建标签：在源码里添加注释信息，比如// +build linux,该标签决定了源码文件只能在 Linux 平台上才会被编译</li><li>文件后缀：改变 Go 语言代码文件的后缀，比如 foo_linux.go，该后缀决定了源码文件只在 Linux 平台上才会被编译</li></ul></blockquote><ul><li>gengo 收集 Go 包信息可分为两步：第一步，为生成的代码文件设置构建标签；第二步，收集 Go 包信息并读取源码内容。</li></ul><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>代码解析流程分为三步：</p><ol><li><p>通过标准库 go/tokens 提供的 Lexer 词法分析器对代码文本进行词法分析，最终得到 Tokens;</p></li><li><p>通过标准库 go/parser 和 go/ast 将 Tokens 构建为抽象语法树（AST）；</p></li><li><p>通过标准库 go/types 下的 Check 方法进行抽象语法树类型检查，完成代码解析过程；</p></li></ol><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>gengo 的类型系统在 Go 语言本身的类型系统之上归类并添加了几种类型。在 Go 语言标准库 go/types 的基础上进行封装。所有的类型都通过 vendor/k8s.io/gengo/parser/parse.go 的 walkType 方法进行识别。gengo 类型系统中的 Struct、Map、Pointer、Interface等，与 Go 语言提供的类型并无差别。也有 gengo 与 Go 语言不同的类型，例如 Builtin、Alias、DeclarationOf、Unknown、Unsupported及Protobuf。另外，Signature并非是一个类型，它依赖于 Func 函数类型，用来描述 Func 函数的接收参数信息和返回值信息等。</p><p>如下举例：</p><h4 id="Builtin（内置类型）"><a href="#Builtin（内置类型）" class="headerlink" title="Builtin（内置类型）"></a>Builtin（内置类型）</h4><p>Builtin 将多种 Base 类型归类成一种类型，以下几种类型在 gengo 中统称为 Builtin 类型。</p><ul><li>内置字符串类型——string</li><li>内置布尔类型——bool</li><li>内置数字类型——int、float、complex64等</li></ul><h4 id="Alias（别名类型）"><a href="#Alias（别名类型）" class="headerlink" title="Alias（别名类型）"></a>Alias（别名类型）</h4><p>举例如下：</p><pre><code>type T1 struct{}type T2 = T1</code></pre><p>这里的 T2 相当于 T1 的别名，但在 Go 语言标准库的 reflect（反射）包识别 T2 的原始类型时，会将它识别为 Struct 类型，而无法将它识别为 Alias 类型，原因是，Alias 类型在运行时是不可见的。由于 gengo 依赖于 go/types 的 Named 类型，所以要让 Alias 类型在运行时可被识别，在声明时将 TypeName 对象绑定到 Named 类型即可。</p><h4 id="DeclarationOf（声明类型）"><a href="#DeclarationOf（声明类型）" class="headerlink" title="DeclarationOf（声明类型）"></a>DeclarationOf（声明类型）</h4><p>它并不是严格意义上的类型，它是声明过的函数、全局变量、或常量，但未被引用过。</p><h4 id="Unknown（未知类型）"><a href="#Unknown（未知类型）" class="headerlink" title="Unknown（未知类型）"></a>Unknown（未知类型）</h4><p>当对象匹配不到以上所有类型的时候，它就是 Unknwn 类型的。</p><h4 id="Unsupported（未支持类型）"><a href="#Unsupported（未支持类型）" class="headerlink" title="Unsupported（未支持类型）"></a>Unsupported（未支持类型）</h4><p>当对象属于 Unkonwn 类型时，则会设置对象为 Unsupported 类型，并在其使用过程中报错。</p><h4 id="Protobuf（Protobuf-类型）"><a href="#Protobuf（Protobuf-类型）" class="headerlink" title="Protobuf（Protobuf 类型）"></a>Protobuf（Protobuf 类型）</h4><p>由 go-to-protobuf 代码生成器单独处理的类型。</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>Kubernetes 代码生成器生成的是 Go 语言代码。</p><p>Generator 接口字段说明如下：</p><blockquote><p>位于 vendor/k8s.io/gengo/generator/generator.go 中</p></blockquote><ul><li>Name: 代码生成器的名称，返回值为生成的目标代码文件名的前缀，例如 deepcopy-gen 的前缀为 zz_generated.deepcopy</li><li>Filter: 类型过滤器，过滤掉不符合当前代码生成器所需的类型</li><li>Namers: 命名管理器，支出创建不同类型的名称。例如，根据类型生成名称</li><li>Init: 代码生成器生成代码之前的初始化操作</li><li>Finalize: 代码生成器生成代码之后的收尾操作</li><li>PackageVars: 生成全局变量代码块，例如 var…</li><li>PackageConsts: 生成常量代码块，例如 consts…</li><li>GenerateType: 生成代码块，根据传入的类型生成代码</li><li>Imports: 获得需要生成的 import 代码块</li><li>Filename: 生成目标代码文件的全名，例如 deepcopy-gen 的 zz_generated.deepcopy.go</li><li>FileType: 生成代码文件的类型<blockquote><p>如果代码生成器没有实现某些方法，则继承默认代码生成器(DefaultGen)的方法</p></blockquote></li></ul><p>下面以 deepcopy-gen 代码生成器为例，其代码生成原理如下：</p><p>首先通过 build.sh 脚本，手动构建 deepcopy-gen 代码生成器二进制文件，然后将需要生成的包 k8s.io/kubernetes/pkg/apis/abac/v1beta1 作为 deepcopy-gen 的输入源，并在内部进行一系列解析，最终通过 -O 参数生成名为 zz_generated.deepcopy.go 的代码文件,以下分步详解：</p><ol><li>实例化 generator.Packages 对象</li></ol><ul><li>deepcopy-gen 代码生成器根据输入的包的目录路径（即输入源），实例化 generator.Packages 对象，根据 generator.Packages 结构生成代码；</li><li>最主要的是 GeneratorFunc 定义了 Generator 接口的实现，</li></ul><ol start="2"><li>执行代码生成</li></ol><p>在 gengo 中，generator 定义代码生成器通用接口 Generator。通过 ExecutePackage 函数，调用不同代码生成器的 Generator 接口方法，并生成代码。</p><p>ExecutePackage 代码生成执行流程：生成 Header 代码块 -&gt; 生成 Imports 代码块 -&gt; 生成 Vars 全局变量代码块 -&gt; 生成 Consts 常量代码块 -&gt; 生成 Body 代码块。最后，调用 assembler.AssembleFile 函数，将生成的代码块信息写入 zz_generated.deepcopy.go 文件，生成 pkg/apis/abac/v1beta1/zz_generated.deepcopy.go 代码结构。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubernetes构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes源码架构</title>
      <link href="kubernetes-yuan-ma-jia-gou/"/>
      <url>kubernetes-yuan-ma-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes架构图"><a href="#Kubernetes架构图" class="headerlink" title="Kubernetes架构图"></a>Kubernetes架构图</h2><p><img src="../image/kubernetes%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="kubernetes架构图"></p><h2 id="Kubernetes各组件功能"><a href="#Kubernetes各组件功能" class="headerlink" title="Kubernetes各组件功能"></a>Kubernetes各组件功能</h2><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><ul><li>集群的 HTTP REST API 接口，是集群控制的入口</li><li>也是集群中唯一与 Etcd 集群进行交互的核心组件<blockquote><p>Etcd 集群是分布式键值存储集群，提供了可靠的强一致性服务发现</p></blockquote></li></ul><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><ul><li>集群中所有资源对象的自动化控制中心</li><li>每个控制器通过 kube-apiserver 组件提供的接口实时监控整个集群每个资源对象的当前状态，当因发生各种故障而导致系统状态出现变化时，会尝试将系统状态修复到“期望状态”</li><li>Controller Manager 具备高可用性（多实例同时运行）<blockquote><p>即基于 Etcd 集群上的分布式锁实现领导者选举机制，多实例同时运行，通过 kube-apiserver 提供的资源锁进行选举竞争。抢先获取锁的实例被称为 Leader 节点（即领导者节点），并运行该组件的主逻辑，而未获取锁的实例被称为 Candidate 节点（即候选节点），运行时处于阻塞状态。在 Leader 节点因某些原因退出后，Candidate 节点则通过领导者选举机制参与竞选，成为 Leader 节点后接替该组件的工作</p></blockquote></li></ul><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><ul><li>集群中 Pod 资源对象的调度服务</li><li>kube-scheduler 具备高可用性（多实例同时运行）具体同上<blockquote><p>具体调度我会在后面仔细整理，里面其实很有趣好玩</p></blockquote></li></ul><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><ul><li>负责管理节点上容器的创建、删除、启停等任务，与 Master 节点进行通信</li></ul><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><ul><li>负责 kubernetes 服务的通信及负载均衡服务</li><li>通过 iptables/ipvs 等配置负载均衡器，为一组 pod 提供统一的 TCP/UDP 流量转发和负载均衡功能</li></ul><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><ul><li>负责容器的基础管理服务，接受 kubelet 组件的指令</li></ul><h3 id="client-go"><a href="#client-go" class="headerlink" title="client-go"></a>client-go</h3><ul><li>是从 kubernetes 代码中单独抽离出来的包，并作为官方提供的 Go 语言客户端发挥作用</li><li>kubernetes 系统的其他组件与 kubernetes API Server 通信的方式也是基于 client-go 实现<blockquote><p>因此在基于 kubernetes 做二次开发的过程中，建议通过 client-go 来实现与 kubernetes API Server 的交互过程</p></blockquote></li></ul><h2 id="Kubernetes-Project-Layout设计"><a href="#Kubernetes-Project-Layout设计" class="headerlink" title="Kubernetes Project Layout设计"></a>Kubernetes Project Layout设计</h2><table><thead><tr><th>源码目录</th><th>说明</th></tr></thead><tbody><tr><td>cmd/</td><td>存放可执行文件的代码入口，每个可执行文件都会对应一个main函数</td></tr><tr><td>pkg/</td><td>存放核心库代码， 可被项目内外部直接饮用</td></tr><tr><td>vendor/</td><td>存放项目的依赖库代码，一般为第三方库代码</td></tr><tr><td>api/</td><td>存放 OpenAPI/Swagger 的 spec 文件，包括 Json, Protocol 的定义等</td></tr><tr><td>build/</td><td>存放构建相关的脚本</td></tr><tr><td>test/</td><td>存放测试工具以及测试数据</td></tr><tr><td>docs/</td><td>存放设计或用户使用文档</td></tr><tr><td>hack/</td><td>存放与构建和测试相关的脚本</td></tr><tr><td>third_party/</td><td>存放第三方工具、代码和组件</td></tr><tr><td>plugin/</td><td>存放 Kubernetes 插件代码目录，例如认证、授权等相关插件</td></tr><tr><td>staging/</td><td>存放部分核心库的暂存目录</td></tr><tr><td>translations/</td><td>存放用于支持不同语言的相关文件</td></tr></tbody></table><h2 id="Kube-apiserver的初始化过程"><a href="#Kube-apiserver的初始化过程" class="headerlink" title="Kube-apiserver的初始化过程"></a>Kube-apiserver的初始化过程</h2><ol><li><strong>rand.Seed</strong>: 组件中的全局随机数生成对象。</li><li><strong>app.NewCommand</strong>: 实例化命令行参数。通过 flags 对命令行参数进行解析并存储至 Options 对象中。</li><li><strong>logs.InitLogs</strong>: 实例化日志对象，用于日志管理。</li><li><strong>command.Execute</strong>: 组件进程运行的逻辑。运行前通过 Complete 函数填充默认参数，通过 Validate 函数验证所有参数，最后通过 Run 函数持久运行。只有当进程收到退出信号时，进程才会退出。<blockquote><p>tips: Kubernetes 其他组件的 cmd 设计与之类似。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubernetes架构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
