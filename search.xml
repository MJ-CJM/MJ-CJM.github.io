<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes核心数据结构1.0</title>
      <link href="kubernetes-he-xin-shu-ju-jie-gou-1-0/"/>
      <url>kubernetes-he-xin-shu-ju-jie-gou-1-0/</url>
      
        <content type="html"><![CDATA[<h2 id="Group、Version、Resource核心数据结构"><a href="#Group、Version、Resource核心数据结构" class="headerlink" title="Group、Version、Resource核心数据结构"></a>Group、Version、Resource核心数据结构</h2><p>在整个 Kubernetes 体系架构中，资源是 Kubernetes 最重要的概念，它本质上是一个资源控制系统————注册、管理、调度资源并维护资源的状态。</p><p>Kubernetes 将资源进行分组和版本化，形成 Group、Version、Resource。具体机构图如下：</p><p><img src="../image/kubernetes%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="kubernetes核心数据结构图"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes构建过程1.0</title>
      <link href="kubernetes-gou-jian-guo-cheng/"/>
      <url>kubernetes-gou-jian-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><h3 id="举例5个代码生成器"><a href="#举例5个代码生成器" class="headerlink" title="举例5个代码生成器"></a>举例5个代码生成器</h3><table><thead><tr><th>代码生成器</th><th>说明</th></tr></thead><tbody><tr><td>conversion-gen</td><td>自动生成 Convert 函数的代码生成器，用于资源对象的版本转换函数</td></tr><tr><td>deepcopy-gen</td><td>自动生成 DeepCopy 函数的代码生成器，用于资源对象的深复制函数</td></tr><tr><td>defaulter-gen</td><td>自动生成 Defaulter 函数的代码生成器，用于资源对象的默认值函数</td></tr><tr><td>go-bindata</td><td>是一个第三方工具，它能够将静态资源文件嵌入 Go 语言中</td></tr><tr><td>openapi-gen</td><td>自动生成 OpenAPI 定义文件的代码生成器</td></tr></tbody></table><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>代码生成器通过 Tags(标签)来识别一个包是否需要生成代码及确定生成代码的方式，Kubernetes 提供的 Tags 可以分为如下两种，Tags 被定义在注释中。</p><h4 id="全局-Tags"><a href="#全局-Tags" class="headerlink" title="全局 Tags"></a>全局 Tags</h4><ul><li>定义在每个包的 doc.go文件中，对整个包中的类型自动生成代码</li><li>代码示例如下：</li></ul><pre><code>// +k8s:deepcopy-gen=package// +groupName=example.com</code></pre><p>该示例表示为包中的每个类型自动生成 DeepCopy 函数，其中// +groupName定义了资源组名称，资源组名称一般用域名形式表示</p><h4 id="局部-Tags"><a href="#局部-Tags" class="headerlink" title="局部 Tags"></a>局部 Tags</h4><ul><li>定义在 Go 语言的类型声明上方，只对指定的类型自动生成代码</li><li>代码示例如下：</li></ul><pre><code>// +genclient// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object// Pod...</code></pre><p>该代码示例局部 Tags 定义在 Pod 资源类型的上方，定义并执行两个代码生成器。</p><blockquote><p>Kubernetes 的 API 文档生成器会根据类型声明的注释信息生成文档，为了避免 Tags 信息出现在文档中，所以将 Tags 定义在注释的上方并空一行</p></blockquote><h4 id="deepcopy-gen-代码生成器"><a href="#deepcopy-gen-代码生成器" class="headerlink" title="deepcopy-gen 代码生成器"></a>deepcopy-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 DeepCopy 相关函数，这些函数可以有效地执行每种类型的深复制操作。</p><p>有如下几种 Tags 形式：</p><ul><li><p>为整个包生成 DeepCopy 相关函数：</p><pre><code>// +k8s:deepcopy-gen=package</code></pre></li><li><p>为单个类型生成 DeepCopy 相关函数：</p><pre><code>// +k8s:deepcopy-gen=true</code></pre></li><li><p>为整个包生成 DeepCopy 相关函数时，可以忽略单个类型：</p><pre><code>// +k8s:deepcopy-gen=false</code></pre></li><li><p>deepcopy-gen 会遍历包中所有类型，若类型为 types.Struct,则会为该类型生成深复制函数。</p></li></ul><h4 id="defaulter-gen-代码生成器"><a href="#defaulter-gen-代码生成器" class="headerlink" title="defaulter-gen 代码生成器"></a>defaulter-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 Defaulter 相关函数，这些函数可以为资源对象生成默认值。</p><ul><li>为拥有不同属性的类型生成不同的 Defaulter 相关函数，其 Tags 形式如下：</li></ul><pre><code>// +k8s:defaulter-gen=TypeMeta/ListMeta/ObjectMeta</code></pre><ul><li>defaulter-gen-input 说明当前包会依赖于指定的路径包，代码示例如下：</li></ul><pre><code>// +k8s:defaulter-gen-input=../../../vendor/k8s.io/api/rbac/v1</code></pre><ul><li>defaulter-gen 会遍历包中所有类型，若类型属性拥有以上三种特定类型，则为该类型生成 Defaulter 函数，并为其生成 RegisterDefaults 注册函数。</li></ul><h4 id="conversion-gen-代码生成器"><a href="#conversion-gen-代码生成器" class="headerlink" title="conversion-gen 代码生成器"></a>conversion-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 Convert 相关函数，这些函数可以为对象在内部和外部类型之间提供转换函数。</p><p>其 Tags 形式如下：</p><ul><li>为整个包生成 Convert 相关函数</li></ul><pre><code>// +k8s:conversion-gen=&lt;peer-pkg&gt;# &lt;peer-pkg&gt; 用于定义包的导入路径</code></pre><ul><li>为整个包生成 Convert 相关函数且依赖其他包时</li></ul><pre><code>// +k8s:conversion-gen-external-types=&lt;type-pkg&gt;# &lt;type-pkg&gt; 用于定义其他包的路径</code></pre><ul><li>在排除某个属性后生成 Convert 相关函数</li></ul><pre><code>// +k8s:conversion-gen=false</code></pre><ul><li>conversion-gen 会遍历包中所有类型，若类型为 types.Struct 且过滤掉了私有 Struct 类型，则为该类型生成 Convert 函数，并为该类型同时生成 RegisterConversions 注册函数</li></ul><h4 id="openapi-gen-代码生成器"><a href="#openapi-gen-代码生成器" class="headerlink" title="openapi-gen 代码生成器"></a>openapi-gen 代码生成器</h4><p>给定一个包的目录路径作为输入源，它可以为其生成 OpenAPI 定义文件，该文件用于 kube-apiserver 服务上的 OpenAPI 规范的生成。</p><ul><li>为特定类型或包生成 OpenAPI 定义文件时</li></ul><pre><code>// +k8s:openapi-gen=true</code></pre><ul><li>排除为特定类型或包生成 OpenAPI 定义时</li></ul><pre><code>// +k8s:openapi-gen=false</code></pre><ul><li>openapi-gen 会遍历包中所有类型，若类型为 types.Struct 并忽略其他类型，则为 types.Struct 类型生成 OpenAPI 定义文件</li></ul><h4 id="go-bindata-代码生成器"><a href="#go-bindata-代码生成器" class="headerlink" title="go-bindata 代码生成器"></a>go-bindata 代码生成器</h4><p>给定一个静态资源目录路径作为输入源，go-bindata 可以为其生成 go 文件</p><h2 id="代码生成过程"><a href="#代码生成过程" class="headerlink" title="代码生成过程"></a>代码生成过程</h2><p>前面所提到的五种代码生成过程如下图所示</p><p><img src="../image/k8s%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt="代码生成过程"></p><ul><li>.todo 文件相当于临时文件，用来存放被 Tags 标记过的包。通过 shell 的 grep 命令可以将所有代码包中被 Tags 标记过的包目录记录在 .todo 文件中，这样可以方便记录哪些包需要使用代码生成功能。</li></ul><h2 id="gengo-代码生成核心实现"><a href="#gengo-代码生成核心实现" class="headerlink" title="gengo 代码生成核心实现"></a>gengo 代码生成核心实现</h2><p>Kubernetes 的代码生成器都是在 k8s.io/gengo 包的基础上实现的，代码生成器都会通过一个输入包路径（–input-dirs）参数，根据 gengo 的词法分析、抽象语法树等操作，最终生成代码并输出（–output-file-base），gengo 代码目录结构说明如下：</p><ul><li><p>args: 代码生成器的通用 flags 参数。</p></li><li><p>examples: 包含 deepcopy-gen、defaulter-gen、import-boss、set-gen等代码生成器的生成逻辑。</p></li><li><p>generator: 代码生成器通用接口 Generator。</p></li><li><p>namer: 命名管理，支持创建不同类型的名称。例如，根据类型生成名称，定义 type foo string，能够生成 func FooPrinter(f *foo){Print(string(*f))}</p></li><li><p>parser: 代码解析器，用来构造抽象语法树。</p></li><li><p>types: 类型系统，用于数据类型的定义及类型检查算法的实现。</p></li></ul><h3 id="代码生成逻辑与编译器原理"><a href="#代码生成逻辑与编译器原理" class="headerlink" title="代码生成逻辑与编译器原理"></a>代码生成逻辑与编译器原理</h3><p><img src="../image/gengo%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86.jpg" alt="gengo代码生成原理"></p><ul><li><p>Gather The Info: 收集 Go 语言源码文件信息及内容</p></li><li><p>Lexer/Parser: 通过 Lexer 词法分析器进行一系列词法分析</p></li><li><p>AST Generator: 生成抽象语法树</p></li><li><p>Type Checker: 对抽象语法树进行类型检查</p></li><li><p>Code Generation: 生成代码，将抽象语法树转换为机器代码</p></li></ul><h3 id="收集-Go-包信息"><a href="#收集-Go-包信息" class="headerlink" title="收集 Go 包信息"></a>收集 Go 包信息</h3><ul><li>采用 go/build 工具，构建标签机制来构建约束条件，例如看代码时常看到类似于//+build linux darwin 的包注释信息，这就是 Go 语言编译时的约束条件，其也被称为条件编译。</li></ul><blockquote><p>Go 语言的条件编译有两种定义方法：</p><ul><li>构建标签：在源码里添加注释信息，比如// +build linux,该标签决定了源码文件只能在 Linux 平台上才会被编译</li><li>文件后缀：改变 Go 语言代码文件的后缀，比如 foo_linux.go，该后缀决定了源码文件只在 Linux 平台上才会被编译</li></ul></blockquote><ul><li>gengo 收集 Go 包信息可分为两步：第一步，为生成的代码文件设置构建标签；第二步，收集 Go 包信息并读取源码内容。</li></ul><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>代码解析流程分为三步：</p><ol><li><p>通过标准库 go/tokens 提供的 Lexer 词法分析器对代码文本进行词法分析，最终得到 Tokens;</p></li><li><p>通过标准库 go/parser 和 go/ast 将 Tokens 构建为抽象语法树（AST）；</p></li><li><p>通过标准库 go/types 下的 Check 方法进行抽象语法树类型检查，完成代码解析过程；</p></li></ol><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>gengo 的类型系统在 Go 语言本身的类型系统之上归类并添加了几种类型。在 Go 语言标准库 go/types 的基础上进行封装。所有的类型都通过 vendor/k8s.io/gengo/parser/parse.go 的 walkType 方法进行识别。gengo 类型系统中的 Struct、Map、Pointer、Interface等，与 Go 语言提供的类型并无差别。也有 gengo 与 Go 语言不同的类型，例如 Builtin、Alias、DeclarationOf、Unknown、Unsupported及Protobuf。另外，Signature并非是一个类型，它依赖于 Func 函数类型，用来描述 Func 函数的接收参数信息和返回值信息等。</p><p>如下举例：</p><h4 id="Builtin（内置类型）"><a href="#Builtin（内置类型）" class="headerlink" title="Builtin（内置类型）"></a>Builtin（内置类型）</h4><p>Builtin 将多种 Base 类型归类成一种类型，以下几种类型在 gengo 中统称为 Builtin 类型。</p><ul><li>内置字符串类型——string</li><li>内置布尔类型——bool</li><li>内置数字类型——int、float、complex64等</li></ul><h4 id="Alias（别名类型）"><a href="#Alias（别名类型）" class="headerlink" title="Alias（别名类型）"></a>Alias（别名类型）</h4><p>举例如下：</p><pre><code>type T1 struct{}type T2 = T1</code></pre><p>这里的 T2 相当于 T1 的别名，但在 Go 语言标准库的 reflect（反射）包识别 T2 的原始类型时，会将它识别为 Struct 类型，而无法将它识别为 Alias 类型，原因是，Alias 类型在运行时是不可见的。由于 gengo 依赖于 go/types 的 Named 类型，所以要让 Alias 类型在运行时可被识别，在声明时将 TypeName 对象绑定到 Named 类型即可。</p><h4 id="DeclarationOf（声明类型）"><a href="#DeclarationOf（声明类型）" class="headerlink" title="DeclarationOf（声明类型）"></a>DeclarationOf（声明类型）</h4><p>它并不是严格意义上的类型，它是声明过的函数、全局变量、或常量，但未被引用过。</p><h4 id="Unknown（未知类型）"><a href="#Unknown（未知类型）" class="headerlink" title="Unknown（未知类型）"></a>Unknown（未知类型）</h4><p>当对象匹配不到以上所有类型的时候，它就是 Unknwn 类型的。</p><h4 id="Unsupported（未支持类型）"><a href="#Unsupported（未支持类型）" class="headerlink" title="Unsupported（未支持类型）"></a>Unsupported（未支持类型）</h4><p>当对象属于 Unkonwn 类型时，则会设置对象为 Unsupported 类型，并在其使用过程中报错。</p><h4 id="Protobuf（Protobuf-类型）"><a href="#Protobuf（Protobuf-类型）" class="headerlink" title="Protobuf（Protobuf 类型）"></a>Protobuf（Protobuf 类型）</h4><p>由 go-to-protobuf 代码生成器单独处理的类型。</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>Kubernetes 代码生成器生成的是 Go 语言代码。</p><p>Generator 接口字段说明如下：</p><blockquote><p>位于 vendor/k8s.io/gengo/generator/generator.go 中</p></blockquote><ul><li>Name: 代码生成器的名称，返回值为生成的目标代码文件名的前缀，例如 deepcopy-gen 的前缀为 zz_generated.deepcopy</li><li>Filter: 类型过滤器，过滤掉不符合当前代码生成器所需的类型</li><li>Namers: 命名管理器，支出创建不同类型的名称。例如，根据类型生成名称</li><li>Init: 代码生成器生成代码之前的初始化操作</li><li>Finalize: 代码生成器生成代码之后的收尾操作</li><li>PackageVars: 生成全局变量代码块，例如 var…</li><li>PackageConsts: 生成常量代码块，例如 consts…</li><li>GenerateType: 生成代码块，根据传入的类型生成代码</li><li>Imports: 获得需要生成的 import 代码块</li><li>Filename: 生成目标代码文件的全名，例如 deepcopy-gen 的 zz_generated.deepcopy.go</li><li>FileType: 生成代码文件的类型<blockquote><p>如果代码生成器没有实现某些方法，则继承默认代码生成器(DefaultGen)的方法</p></blockquote></li></ul><p>下面以 deepcopy-gen 代码生成器为例，其代码生成原理如下：</p><p>首先通过 build.sh 脚本，手动构建 deepcopy-gen 代码生成器二进制文件，然后将需要生成的包 k8s.io/kubernetes/pkg/apis/abac/v1beta1 作为 deepcopy-gen 的输入源，并在内部进行一系列解析，最终通过 -O 参数生成名为 zz_generated.deepcopy.go 的代码文件,以下分步详解：</p><ol><li>实例化 generator.Packages 对象</li></ol><ul><li>deepcopy-gen 代码生成器根据输入的包的目录路径（即输入源），实例化 generator.Packages 对象，根据 generator.Packages 结构生成代码；</li><li>最主要的是 GeneratorFunc 定义了 Generator 接口的实现，</li></ul><ol start="2"><li>执行代码生成</li></ol><p>在 gengo 中，generator 定义代码生成器通用接口 Generator。通过 ExecutePackage 函数，调用不同代码生成器的 Generator 接口方法，并生成代码。</p><p>ExecutePackage 代码生成执行流程：生成 Header 代码块 -&gt; 生成 Imports 代码块 -&gt; 生成 Vars 全局变量代码块 -&gt; 生成 Consts 常量代码块 -&gt; 生成 Body 代码块。最后，调用 assembler.AssembleFile 函数，将生成的代码块信息写入 zz_generated.deepcopy.go 文件，生成 pkg/apis/abac/v1beta1/zz_generated.deepcopy.go 代码结构。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes源码架构</title>
      <link href="kubernetes-yuan-ma-jia-gou/"/>
      <url>kubernetes-yuan-ma-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes架构图"><a href="#Kubernetes架构图" class="headerlink" title="Kubernetes架构图"></a>Kubernetes架构图</h2><p><img src="../image/kubernetes%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="kubernetes架构图"></p><h2 id="Kubernetes各组件功能"><a href="#Kubernetes各组件功能" class="headerlink" title="Kubernetes各组件功能"></a>Kubernetes各组件功能</h2><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><ul><li>集群的 HTTP REST API 接口，是集群控制的入口</li><li>也是集群中唯一与 Etcd 集群进行交互的核心组件<blockquote><p>Etcd 集群是分布式键值存储集群，提供了可靠的强一致性服务发现</p></blockquote></li></ul><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><ul><li>集群中所有资源对象的自动化控制中心</li><li>每个控制器通过 kube-apiserver 组件提供的接口实时监控整个集群每个资源对象的当前状态，当因发生各种故障而导致系统状态出现变化时，会尝试将系统状态修复到“期望状态”</li><li>Controller Manager 具备高可用性（多实例同时运行）<blockquote><p>即基于 Etcd 集群上的分布式锁实现领导者选举机制，多实例同时运行，通过 kube-apiserver 提供的资源锁进行选举竞争。抢先获取锁的实例被称为 Leader 节点（即领导者节点），并运行该组件的主逻辑，而未获取锁的实例被称为 Candidate 节点（即候选节点），运行时处于阻塞状态。在 Leader 节点因某些原因退出后，Candidate 节点则通过领导者选举机制参与竞选，成为 Leader 节点后接替该组件的工作</p></blockquote></li></ul><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><ul><li>集群中 Pod 资源对象的调度服务</li><li>kube-scheduler 具备高可用性（多实例同时运行）具体同上<blockquote><p>具体调度我会在后面仔细整理，里面其实很有趣好玩</p></blockquote></li></ul><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><ul><li>负责管理节点上容器的创建、删除、启停等任务，与 Master 节点进行通信</li></ul><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><ul><li>负责 kubernetes 服务的通信及负载均衡服务</li><li>通过 iptables/ipvs 等配置负载均衡器，为一组 pod 提供统一的 TCP/UDP 流量转发和负载均衡功能</li></ul><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><ul><li>负责容器的基础管理服务，接受 kubelet 组件的指令</li></ul><h3 id="client-go"><a href="#client-go" class="headerlink" title="client-go"></a>client-go</h3><ul><li>是从 kubernetes 代码中单独抽离出来的包，并作为官方提供的 Go 语言客户端发挥作用</li><li>kubernetes 系统的其他组件与 kubernetes API Server 通信的方式也是基于 client-go 实现<blockquote><p>因此在基于 kubernetes 做二次开发的过程中，建议通过 client-go 来实现与 kubernetes API Server 的交互过程</p></blockquote></li></ul><h2 id="Kubernetes-Project-Layout设计"><a href="#Kubernetes-Project-Layout设计" class="headerlink" title="Kubernetes Project Layout设计"></a>Kubernetes Project Layout设计</h2><table><thead><tr><th>源码目录</th><th>说明</th></tr></thead><tbody><tr><td>cmd/</td><td>存放可执行文件的代码入口，每个可执行文件都会对应一个main函数</td></tr><tr><td>pkg/</td><td>存放核心库代码， 可被项目内外部直接饮用</td></tr><tr><td>vendor/</td><td>存放项目的依赖库代码，一般为第三方库代码</td></tr><tr><td>api/</td><td>存放 OpenAPI/Swagger 的 spec 文件，包括 Json, Protocol 的定义等</td></tr><tr><td>build/</td><td>存放构建相关的脚本</td></tr><tr><td>test/</td><td>存放测试工具以及测试数据</td></tr><tr><td>docs/</td><td>存放设计或用户使用文档</td></tr><tr><td>hack/</td><td>存放与构建和测试相关的脚本</td></tr><tr><td>third_party/</td><td>存放第三方工具、代码和组件</td></tr><tr><td>plugin/</td><td>存放 Kubernetes 插件代码目录，例如认证、授权等相关插件</td></tr><tr><td>staging/</td><td>存放部分核心库的暂存目录</td></tr><tr><td>translations/</td><td>存放用于支持不同语言的相关文件</td></tr></tbody></table><h2 id="Kube-apiserver的初始化过程"><a href="#Kube-apiserver的初始化过程" class="headerlink" title="Kube-apiserver的初始化过程"></a>Kube-apiserver的初始化过程</h2><ol><li><strong>rand.Seed</strong>: 组件中的全局随机数生成对象。</li><li><strong>app.NewCommand</strong>: 实例化命令行参数。通过 flags 对命令行参数进行解析并存储至 Options 对象中。</li><li><strong>logs.InitLogs</strong>: 实例化日志对象，用于日志管理。</li><li><strong>command.Execute</strong>: 组件进程运行的逻辑。运行前通过 Complete 函数填充默认参数，通过 Validate 函数验证所有参数，最后通过 Run 函数持久运行。只有当进程收到退出信号时，进程才会退出。<blockquote><p>tips: Kubernetes 其他组件的 cmd 设计与之类似。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
